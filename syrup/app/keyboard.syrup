from wafflecore.compute import (matrix_placement, rotates_ortho_new, cuboid_transformed)
from wafflecore.animation import animate
from wafflecore.camera import camera_translate

(object keyboard) new_keyboard():
    KEYS = ["a","d","s","w", "c", "e", "j", "l", "k", "i"]
    keys = {}
    for key in KEYS:
        keys{key} = {
            "state": "KEY_UP",
            "down_time": 0
        }
    keyboard = { "keys_state": keys }
# if you hold the key down, glut will keep generating key_pressed events
# TODO:redo keyboard stuff. trigger immediately.
() keyboard_on_event(object state, string button, string key_state):
    keys_state = state.keyboard.keys_state
    for key in keys(keys_state):
        if button == key:
            old_state = keys_state{button}.state
            if old_state != key_state:
                keys_state{button}.state = key_state
                if key_state == "KEY_DOWN":
                    keys_state{button}.down_time = state.now
            break

# if any key is down, move in that direction (but only one
# direction).
# if no key is down, don't move.
() keyboard_idle(object state):
    keys_state = state.keyboard.keys_state
    for key in keys(keys_state):
        key_state = keys_state{key}
        if key_state.state == "KEY_DOWN":
            keyboard_on_down(state, key, key_state)
            return

    keyboard_none(state)
    #record("handler released: {}".format( key))

() keyboard_none(object state):
    state.pacman.velocity = [0.0, 0.0, 0.0]

(number next) loop_next(number index, number length):
    next = index + 1
    if next >= length:
        next = 0

() animate_pacman(object state, object pacman, object elapsed_time):
    animation = state.animations.pacman
    animate(animation, pacman, state.geometries, elapsed_time)

# assumes that by default:
#  1. pacman is facing right.
#  2. pacman's bounds position is [0.0, 0.0, 0.0].
() place_pacman(object pacman, number axis, number sign):
    matrix = matrix_placement(pacman.position, pacman.rotates)
    #print(["place_pacman matrix", matrix])
    bounds = pacman.bounds
    (new_point, new_size) = cuboid_transformed(matrix, bounds.position, bounds.size)
    #point = point_transformed(matrix, pacman.bounds.position)
    #print(["place_pacman position rotates, point", pacman.position, pacman.rotates, new_point])
    bound_size = bounds.size
    if axis == 0:
        if sign == 0:
            pacman.position = [new_point[0] + bound_size[0], new_point[1] + bound_size[1], new_point[2]]
            pacman.rotates = rotates_ortho_new(180, 2, 0, 0)
        else:
            pacman.position = new_point
            pacman.rotates = []
    elif axis == 1:
        if sign == 0:
            pacman.position = [new_point[0], new_point[1], new_point[2] + bound_size[2]]
            pacman.rotates = rotates_ortho_new(90, 1, 0, 0)
        else:
            pacman.position = [new_point[0] + bound_size[0], new_point[1], new_point[2]]
            pacman.rotates = rotates_ortho_new(270, 1, 0, 0)


() keyboard_on_down(object state, string key, object key_state):
    #state.keyboard.
    elapsed_time = state.now - key_state.down_time
    pacman = state.pacman
    #print(["keyboard_on_down inside", key, key_state])
    keys = ["j", "l", "k", "i"]
    plus = state.pacman.input_velocity
    minus = -1*plus
    velocities = [[minus,0,0], [plus,0,0],[0,0,minus],[0,0,plus]]
    places = [[0,0], [0,1], [1,0], [1,1]]
    for i in range(4):
        if key == keys[i]:
            pacman.velocity = velocities[i]
            #print(["keyboard_on_down", pacman.velocity])
            place_pacman(pacman, places[i][0], places[i][1])
            animate_pacman(state, pacman, elapsed_time)
            break

    camera = state.camera
    scale = 1.0
    rotate_scale = 0.1
    translate_keys = ["a", "d", "s", "w", "c", "e"]
    axes = [ [0,0], [0,1], [1,0], [1,1], [2,0], [2,1] ]
    print(["camera before", camera.placement])
    for i in range(6):
        this_key = translate_keys[i]
        if key == this_key:
            camera_translate(scale, axes[i][0], axes[i][1], camera)
            return


() move_old(object state, array distance):
    move_keys = ["a", "d", "s", "w"]
    speed = 1
    # time since user pressed and held on to key
    #distance = integer(speed * elapsed_time)
    pacman = state.pacman
    if distance[0] > 0:
        place_pacman(pacman, 0, 1)
        animate_pacman(state, pacman, elapsed_time)
    elif distance[2] < 0:
        place_pacman(pacman, 1, 0)
        animate_pacman(state, pacman, elapsed_time)
    elif distance[2] > 0:
        place_pacman(pacman, 1, 1)
        animate_pacman(state, pacman, elapsed_time)

