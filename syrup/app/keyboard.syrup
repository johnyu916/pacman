from wafflecore.compute import (matrix_placement, rotates_ortho_new, cuboid_transformed)
from wafflecore.animation import animate

(object keyboard) new_keyboard():
    KEYS = ["a","d","s","w"]
    keys = {}
    for key in KEYS:
        keys{key} = {
            "state": "KEY_UP",
            "down_time": 0
        }
    keyboard = { "keys_state": keys }
# if you hold the key down, glut will keep generating key_pressed events
() keyboard_on_event(object state, string button, string key_state):
    keys_state = state.keyboard.keys_state
    for key in keys(keys_state):
        if button == key:
            if key_state == "KEY_DOWN":
                old_state = keys_state{button}.state
                if old_state == "KEY_UP":
                    keys_state{button}.state = key_state
                    keys_state{button}.down_time = time()
            else:
                keys_state{button}.state = key_state
            break

() keyboard_idle(object state):
    keys_state = state.keyboard.keys_state
    for key in keys(keys_state):
        key_state = keys_state{key}
        if key_state.state == "KEY_DOWN":
            keyboard_on_down(state, key, key_state)
    #else:
    #    keyboard_on_release(state, key)
        #record("handler released: {}".format( key))

() keyboard_on_release(object state, string key):
    return

(number next) loop_next(number index, number length):
    next = index + 1
    if next >= length:
        next = 0

() animate_pacman(object state, object pacman, object elapsed_time):
    animation = state.animations.pacman
    animate(animation, pacman, state.geometries, elapsed_time)
    #names = length(pacman.geometry_names)
    #next = loop_next(pacman.geometry_index, names)
    #pacman.geometry_index = next
    #pacman.geometry = state.geometries{pacman.geometry_names[next]}

() place_pacman(object pacman, number axis, number sign):
    matrix = matrix_placement(pacman.position, pacman.rotates)
    #print(["place_pacman matrix", matrix])
    bounds = pacman.bounds
    (new_point, new_size) = cuboid_transformed(matrix, bounds.position, bounds.size)
    #point = point_transformed(matrix, pacman.bounds.position)
    #print(["place_pacman position rotates, point", pacman.position, pacman.rotates, new_point])
    if axis == 0:
        if sign == 0:
            pacman.position = [new_point[0] + 13, new_point[1] + 1, new_point[2]]
            pacman.rotates = rotates_ortho_new(180, 2, 0, 0)
        else:
            pacman.position = new_point
            pacman.rotates = []
    elif axis == 1:
        if sign == 0:
            pacman.position = [new_point[0], new_point[1], new_point[2] + 13]
            pacman.rotates = rotates_ortho_new(90, 1, 0, 0)
        else:
            pacman.position = [new_point[0] + 13, new_point[1], new_point[2]]
            pacman.rotates = rotates_ortho_new(270, 1, 0, 0)


() keyboard_on_down(object state, string key, object key_state):
    #state.keyboard.
    elapsed_time = state.now - key_state.down_time
    pacman = state.pacman

    keys = ["a", "d", "s", "w"]
    plus = state.pacman.input_velocity
    minus = -1*plus
    velocities = [[minus,0,0], [plus,0,0],[0,0,minus],[0,0,plus]]
    places = [[0,0], [0,1], [1,0], [1,1]]
    for i in range(4):
        if key == keys[i]:
            pacman.velocity = velocities[i]
            place_pacman(pacman, places[i][0], places[i][1])

    animate_pacman(state, pacman, elapsed_time)


() move_old(object state, array distance):
    move_keys = ["a", "d", "s", "w"]
    speed = 1
    # time since user pressed and held on to key
    #distance = integer(speed * elapsed_time)
    pacman = state.pacman
    if distance[0] > 0:
        place_pacman(pacman, 0, 1)
        animate_pacman(state, pacman, elapsed_time)
    elif distance[2] < 0:
        place_pacman(pacman, 1, 0)
        animate_pacman(state, pacman, elapsed_time)
    elif distance[2] > 0:
        place_pacman(pacman, 1, 1)
        animate_pacman(state, pacman, elapsed_time)

