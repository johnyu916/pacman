from wafflecore.compute import (matrix_placement, rotates_ortho_new, cuboid_transformed, array_scaled, sum_arrays, subtract_arrays, distance_directional)
from keyboard import keyboard_idle
() idle(object state):
    now = time()
    delta = now - state.now
    state.now = now

    # 1. calculate the force, velocity, and position.
    # 2. attempt to apply the change in position,
    #    but do not go through anything.
    for thing in state.world.children:
        matrix = matrix_placement(thing.position, thing.rotates)
        bounds = thing.bounds
        (position, size) = cuboid_transformed(matrix, bounds.position, bounds.size)
        #print([thing.type, thing.force])
        accel = array_scaled(thing.force, 1.0/thing.mass)
        velocity_i = thing.velocity
        velocity_f = sum_arrays(array_scaled(accel, delta), velocity_i)
        velocity_avg = array_scaled(sum_arrays(velocity_f, velocity_i) , 1/2.0)
        # new velocity
        thing.velocity = velocity_f

        distance_delta = array_scaled(velocity_avg, delta)
        position_i = position
        position_f = sum_arrays(position_i, distance_delta)

        # crash it against others
        (crash_position, hit_thing) = crash(thing.id, position_i, position_f, size, state.world.children)
        if hit_thing != null:
            #print(["idle hit_thing", hit_thing.type])
            thing.velocity = [0.0, 0.0, 0.0]
        thing.force = [0.0, 0.0, 0.0]

        delta = subtract_arrays(crash_position, position)
        #print(["idle delta", delta])
        last = sum_arrays(thing.position, delta)
        thing.position = [last[0], last[1], last[2]]

    keyboard_idle(state)

() do_friction(object state):
    # do friction stuff later.
    pacman = state.pacman
    pacman_id = pacman.id
    matrix = matrix_placement(pacman.position, pacman.rotates)
    bounds = pacman.bounds
    (new_point, new_size) = cuboid_transformed(matrix, bounds.position, bounds.size)

    for child in state.world.children:
        if child.id != pacman_id:
            matrix = matrix_placement(child.position, child.rotates)
            bounds = child.bounds
            (child_point, child_size) = cuboid_transformed(matrix, bounds.position, bounds.size)
            # see if they touch. axis vector
            (axis, sign) = face_overlap(new_point, new_size, child_point, child_size)
            if axis == null:
                continue

            friction_mag = 0
            if sign == 0:
                if thing.force[axis] < 0:
                    friction_mag = coef * thing.force[axis]
            else:
                if thing.force[axis] > 0:
                    friction_mag = coef * thing.force[axis]

            friction = array_scaled(vector_unit(thing.velocity), friction_mag)
            # decrease the force in that direction up to 0.
            thing.force = sum_arrays(thing.force, friction)


# see if i can 
(array final, object hit_thing) crash(number thing_id, array position_i, array position_f, array size, array things):
    delta = subtract_arrays(position_f, position_i)
    #magnitude = vector_magnitude(delta)
    #unit = vector_unit(delta)
    #(axis, sign) = axis_sign_vector(delta)
    min_time = 1.0
    hit_thing = null
    for thing in things:
        if thing.id == thing_id:
            continue

        matrix = matrix_placement(thing.position, thing.rotates)
        bounds = thing.bounds
        (child_point, child_size) = cuboid_transformed(matrix, bounds.position, bounds.size)
        time = distance_directional(delta, child_point, child_size, position_i, size)
        if time < min_time:
            min_time = time
            hit_thing = thing

    scale = array_scaled(delta, min_time)
    final = sum_arrays(position_i, scale)
