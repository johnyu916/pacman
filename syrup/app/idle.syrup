from wafflecore.compute import (matrix_placement, rotates_ortho_new, cuboid_transformed, array_scaled, sum_arrays, subtract_arrays, point_farthest, time_plane_point, is_overlap_cuboids)
from keyboard import keyboard_idle
() idle(object state):
    now = time()
    delta = now - state.now
    state.now = now

    # 1. calculate the force, velocity, and position.
    # 2. attempt to apply the change in position,
    #    but do not go through anything.
    for thing in state.world.children:
        print(["idle 0.5", thing.type, thing.position, thing.bounds])
        matrix = matrix_placement(thing.position, thing.rotates)
        bounds = thing.bounds
        (position, size) = cuboid_transformed(matrix, bounds.position, bounds.size)
        print(["idle 0.6", thing.type, position])
        #print([thing.type, thing.force])
        accel = array_scaled(thing.force, 1.0/thing.mass)
        velocity_i = thing.velocity
        velocity_f = sum_arrays(array_scaled(accel, delta), velocity_i)
        velocity_avg = array_scaled(sum_arrays(velocity_f, velocity_i) , 1/2.0)
        # new velocity
        thing.velocity = velocity_f
        #if thing.type == "Pacman":
        #    print(["idle", velocity_i, velocity_f, velocity_avg])

        if (velocity_avg[0] == 0.0 && velocity_avg[1] == 0.0 && velocity_avg[2] == 0.0):
            continue

        distance_delta = array_scaled(velocity_avg, delta)
        position_i = position
        position_f = sum_arrays(position_i, distance_delta)
        print(["idle", thing.type, position_f, position_i])

        # crash it against others
        (crash_position, hit_thing) = crash(thing.id, position_i, position_f, size, state.world.children)
        if hit_thing != null:
            #print(["idle hit_thing", hit_thing.type])
            thing.velocity = [0.0, 0.0, 0.0]
        thing.force = [0.0, 0.0, 0.0]

        crash_delta = subtract_arrays(crash_position, position)
        #print(["idle delta", crash_delta])
        last = sum_arrays(thing.position, crash_delta)
        thing.position = [last[0], last[1], last[2]]
        print(["idle 2", thing.type, crash_position, thing.position])

    keyboard_idle(state)

() do_friction(object state):
    # do friction stuff later.
    pacman = state.pacman
    pacman_id = pacman.id
    matrix = matrix_placement(pacman.position, pacman.rotates)
    bounds = pacman.bounds
    (new_point, new_size) = cuboid_transformed(matrix, bounds.position, bounds.size)

    for child in state.world.children:
        if child.id != pacman_id:
            matrix = matrix_placement(child.position, child.rotates)
            bounds = child.bounds
            (child_point, child_size) = cuboid_transformed(matrix, bounds.position, bounds.size)
            # see if they touch. axis vector
            (axis, sign) = face_overlap(new_point, new_size, child_point, child_size)
            if axis == null:
                continue

            friction_mag = 0
            if sign == 0:
                if thing.force[axis] < 0:
                    friction_mag = coef * thing.force[axis]
            else:
                if thing.force[axis] > 0:
                    friction_mag = coef * thing.force[axis]

            friction = array_scaled(vector_unit(thing.velocity), friction_mag)
            # decrease the force in that direction up to 0.
            thing.force = sum_arrays(thing.force, friction)


# see if i can 
(array final, object hit_thing) crash(number thing_id, array position_i, array position_f, array size, array things):
    delta = subtract_arrays(position_f, position_i)
    delta_inv = array_scaled(delta, -1)
    peak = point_farthest(position_i, size, delta)
    #magnitude = vector_magnitude(delta)
    #unit = vector_unit(delta)
    #(axis, sign) = axis_sign_vector(delta)
    min_time = 1.0
    hit_thing = null
    for thing in things:
        if thing.id == thing_id:
            continue

        matrix = matrix_placement(thing.position, thing.rotates)
        bounds = thing.bounds
        (child_point, child_size) = cuboid_transformed(matrix, bounds.position, bounds.size)
        child_start = point_farthest(child_point, child_size, delta_inv)
        begin_time = time_plane_point(child_start, delta, peak)
        #time = distance_directional(delta, child_point, child_size)
        if begin_time >= 0.0 && begin_time < min_time:
            child_end = point_farthest(child_point, child_size, delta)
            end_time = time_plane_point(child_end, delta, peak)
            if begin_time == end_time:
                continue
            elif begin_time > end_time:
                print(["Error end_time greater than begin_time", begin_time, end_time])
                continue
            else:
                test_time = (begin_time + end_time)/2.0
                test_position = sum_arrays(position_i, array_scaled(delta, test_time))
                if is_overlap_cuboids(test_position, size, child_point, child_size):
                    min_time = begin_time
                    hit_thing = thing

    scale = array_scaled(delta, min_time)
    final = sum_arrays(position_i, scale)
