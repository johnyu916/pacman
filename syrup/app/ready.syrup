from collisions import (collisions, touching_all)
from keyboard import keyboard_idle
from shared import get_game_state
from ai import ai_idle

() ready_start(object state):
    ready = state.game.state
    ready.time_start = state.now
    #print(["ready_start", state.game])

() ready_idle(object state):
    ready = state.game.state
    elapsed = state.now - ready.time_start
    if state.now > 1.0:
        # start playing
        state.game.state = get_game_state(state, "playing")
        start_state(state)

() dying_idle(object state):
    ready = state.game.state
    elapsed = state.now - ready.time_start
    if state.now > 5.0:
        # change state
        state.game.state = get_game_state(state, "ready")
        start_state(state)
    else:
        animate_pacman(state, pacman, "death")
        livse = state.game.lives
        lives -= 1

        if lives > 0:
            state.game.state = get_game_state(state, "playing")
            start_state(state)
        else:
            state.game.state = get_game_state(state, "game_over")
            start_state(state)

() game_over_start(object state):
    state.world.children = []
    # different keyboard handler

() game_over_idle(object state):
    keys_state = state.keyboard.keys_state
    for key in keys(keys_state):
        if key_state == "KEY_DOWN":
            if key == "q":
                exit()
            elif key == "s":
                state.game.state = get_game_state(state, "ready")
                start_state(state)

() start_state(object state):
    state_name = state.game.state.name
    print(["start_state", state_name])
    if state_name == "ready":
        ready_start(state)
    elif state_name == "playing":
        playing_start(state)
    elif state_name == "dying":
        dying_start(state)

() playing_start(object state):
    state.world.children = []
    append(state.world.children, state.stage)
    append(state.world.children, state.pacman)
    append(state.world.children, state.shadow)

    # dots
    state.game.score = 0
    state.game.highscore = 0
    dots_make(state)
    balls_make(state)

() playing_idle(object state):
    collisions(state)
    touching_all(state)
    game_logic(state)
    keyboard_idle(state)
    ai_idle(state)
    #print(["pacman velocity", state.pacman.velocity])

() dying_start(object state):
    dying = state.game.state
    dying.time_start = state.now

() dots_make(object state):
    dot = {
        "position": [0.0, 0.0, 0.0],
        "children": []
    }
    # TODO: no dots yet
    state.dots = []

() balls_make(object state):
    state.balls = []


# two objects collided. specifically, one ran into two. what to do?
#() handle_collision(object one, object two):
() game_logic(object state):
    pacman = state.pacman
    game = state.game
    for touch in pacman.touching:
        thing = touch.thing
        if thing.type == "Shadow":
            if thing.state == "normal":
                state.game.state = get_game_state(state, "dying")
                start_state("dying")
            elif thing.state == "blue":
                state.game.score += 100
                change_state(thing, "eyes")

    #if (one.type == "Shadow" || two.type == "Shadow") && (one.type == "Pacman" || two.type == "Pacman"):
        # die pacman

    for dot in state.dots:
        if touching_one(pacman, dot):
            game.score += 10
            remove(dots, dot)
            break

    for ball in state.balls:
        if touching_one(pacman, ball):
            game.score += 50
            remove(balls, ball)
            break


() do_friction(object state):
    # do friction stuff later.
    pacman = state.pacman
    pacman_id = pacman.id
    matrix = matrix_placement(pacman.position, pacman.rotates)
    bounds = pacman.bounds
    (new_point, new_size) = cuboid_transformed(matrix, bounds.position, bounds.size)

    for child in state.world.children:
        if child.id != pacman_id:
            matrix = matrix_placement(child.position, child.rotates)
            bounds = child.bounds
            (child_point, child_size) = cuboid_transformed(matrix, bounds.position, bounds.size)
            # see if they touch. axis vector
            (axis, sign) = face_overlap(new_point, new_size, child_point, child_size)
            if axis == null:
                continue

            friction_mag = 0
            if sign == 0:
                if thing.force[axis] < 0:
                    friction_mag = coef * thing.force[axis]
            else:
                if thing.force[axis] > 0:
                    friction_mag = coef * thing.force[axis]

            friction = array_scaled(vector_unit(thing.velocity), friction_mag)
            # decrease the force in that direction up to 0.
            thing.force = sum_arrays(thing.force, friction)

