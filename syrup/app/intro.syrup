from wafflecore.animation import (animate, animation_task)
from wafflecore.compute import (new_id, sum_arrays, array_scaled)
from wafflecore.thing import (thing_new, thing_set_position, thing_set_position_y)
from wafflecore.standard import copy_object
from task import task_exit
from collisions import (bump_thing)
from ai import (animate_enemy, get_enemy_legs, get_ghost_children)
from keyboard import (place_pacman)
from shared import (on_eat, on_eat_done)
from text import get_text

() intro(object state, object task):
    #print("inside intro")
    keys_state = state.keyboard.keys_state
    for key in keys(keys_state):
        key_state = keys_state{key}
        if key_state == "KEY_DOWN":
            if key == "q":
                exit()
            elif key == "s":
                clear_crew(state)
                task_exit(task, {})

    intro = state.game.intro
    if task.step == 0:
        intro_setup(state, task)
    elif task.step == 1:
        # pause for 1 second
        elapsed = state.now - task.camera_start
        if elapsed > 1.0:
            if state.camera.placement.position[2] < 0:
                task.step = 3
            else:
                task.camera_start = state.now
                task.step = 7
    elif task.step == 3:
        intro_run_start(state, task)
        task.step = 4
    elif task.step == 4:
        done = intro_run_left(state, task)
        if done:
            task.step = 5
    elif task.step == 5:
        pause = intro_run_right(state, task)
        if pause == true:
            task.step = 6
    elif task.step == 6:
        done = intro_pause(state, task)
        if done:
            task.step = 5
    elif task.step == 7:
        # move camera for 1 second
        if state.now - task.camera_start > 1:
            task.step = 1
            task.camera_start = state.now
        else:
            intro_move_camera(state, task)


() clear_crew(object state):
    game = state.game
    thing_set_position(game.pacman, [300.0, 0.0, 0])
    for enemy in game.enemies:
        thing_set_position(enemy, [300, 0.0, 0])


() intro_setup(object state, object task):
    game = state.game
    pacman = game.pacman
    thing_set_position(pacman, [40.0, 0.0, 40])
    name_texts = []

    game.ball = thing_new(new_id(state), "Ball", [0,0,0], [], [], state.geometries.ball, null)
    thing_set_position(game.ball, [20.0, 0.0, 40])
    x = 20
    z = 200
    for enemy in game.enemies:
        name_text = get_text(state, enemy.caps, enemy.color)
        thing_set_position(name_text, [x + 20, 0.0, z])
        thing_set_position(enemy, [x, 0.0, z])
        append(name_texts, name_text)
        z -= 40

    task.name_texts = name_texts
    children = [game.intro.chars, pacman, game.ball]
    extend(children, name_texts)
    extend(children, game.enemies)
    extend(children, game.number_bubbles)
    state.world.children = children
    task.number_eaten = 0
    task.step = 7
    task.camera_start = state.now
    state.camera.velocity = [0,0,-50]


() intro_move_camera(object state, object task):
    placement = state.camera.placement
    distance_delta = array_scaled(state.camera.velocity, state.delta)
    placement.position = sum_arrays(placement.position, distance_delta)

() intro_run_start(object state, object task):
    game = state.game
    pacman = game.pacman
    state.camera.placement.position[0] = pacman.world_bounds.position[0]
    z = 40
    v_x = -100
    thing_set_position(pacman, [224.0, 0.0, z])
    #print(["pacman world bounds", pacman.world_bounds])
    pacman.velocity = [v_x, 0, 0]
    task.animations.pacman = animation_task(state.animations.pacman, pacman, state.now)
    place_pacman(pacman, 0, 0)
    x = 250
    for enemy in game.enemies:
        thing_set_position(enemy, [x, 0.0, z])
        enemy.velocity = [v_x, 0, 0]
        animation_name = join([enemy.name, "legs"], "_")
        legs = get_enemy_legs(enemy)
        task.animations{animation_name} = animation_task(state.animations{animation_name}, legs, state.now)
        legs = enemy.ghost_children[1]
        animation_name = join([enemy.name, "ghost_legs"], "_")
        task.animations{animation_name} = animation_task(state.animations{animation_name}, legs, state.now)
        #print(["enemy world bounds", enemy.world_bounds])
        x+=16


# framework for pausing until child is done.
# normal: setup, run, setup, run, setup, run
# subroutine: setup, run, pause, setup, run, resume
# basically, there are children that you block wait on,
# and children that run in parallel (though you do have to wait 
# for them to finish when you are done)

(bool done) intro_run_left(object state, object task):
    game = state.game
    pacman = game.pacman

    if pacman.world_bounds.position[0] < 38:
        thing_set_position_y(game.ball, -1000)
        v_x = 100
        pacman.velocity = [v_x, 0, 0]
        place_pacman(pacman, 0, 1)
        for enemy in game.enemies:
            enemy.children = enemy.ghost_children
            enemy.velocity = [v_x, 0, 0]
        done = true
        return

    delta = state.delta
    #print(["pacman world bounds", pacman.world_bounds])
    bump_thing(pacman, [], delta)
    distance_delta = pacman.position_delta
    state.camera.placement.position[0] = pacman.world_bounds.position[0]
    #print(["distance delta", distance_delta])
    animate(task.animations.pacman, state.things, state.geometries, state.now)
    for enemy in game.enemies:
        animate_enemy(state, task, enemy)
        thing_set_position(enemy, sum_arrays(enemy.position, distance_delta))
        #print(["enemy world bounds", enemy.world_bounds])


(bool pause) intro_run_right(object state, object task):
    game = state.game
    pacman = game.pacman
    if pacman.world_bounds.position[0] > 240:
        # done.
        task_exit(task, {})
        return

    delta = state.delta
    animate(task.animations.pacman, state.things, state.geometries, state.now)
    bump_thing(pacman, game.enemies, delta)
    state.camera.placement.position[0] = pacman.world_bounds.position[0]
    distance_delta = pacman.position_delta
    for enemy in game.enemies:
        name = join([enemy.name, "ghost_legs"], "_")
        animate(task.animations{name}, state.things, state.geometries, state.now)
        thing_set_position(enemy, sum_arrays(enemy.position, [distance_delta[0]/2, 0, 0]))
        #print(["enemy world bounds", enemy.world_bounds])
    for touch in pacman.collisions:
        print(["run_idle hit something", touch.thing.type, touch.thing.position])
        if touch.thing.type == "Enemy":
            # both pacman and enemy disappears.
            # number appears.
            # frozen for a second.
            game.guys_paused_start = state.now
            on_eat(task, game, touch.thing)
            pause = true
            return


(bool done) intro_pause(object state, object task):
    #if game.guys_paused:
        # hang tight
        #print(["paused", state.now - game.guys_paused_start])
    game = state.game
    if (state.now - game.guys_paused_start) > 1.0:
        pacman = game.pacman
        on_eat_done(task, game)
        v_x = 100
        pacman.velocity = [v_x, 0, 0]
        done = true
