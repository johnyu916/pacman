from wafflecore.animation import animate
from wafflecore.compute import (new_id, sum_arrays)
from wafflecore.thing import (thing_new, thing_set_position, thing_set_position_y)
from view import view_exit
from collisions import (bump_thing)
from ai import (move_velocity)
from keyboard import (place_pacman)

() intro(object state, object view):
    #print("inside intro")
    intro = state.game.intro
    if view.step == 0:
        state.world.children = [intro.chars]
        view.number_eaten = 0
        view.step = 1
    elif view.step == 1:
        elapsed = state.now - view.time_start
        if elapsed > 1.0:
            state.world.children = [intro.chars, intro.shadow]
            view.step = 2
    elif view.step == 2:
        elapsed = state.now - view.time_start
        if elapsed > 2.0:
            view.step = 3
            print(["set game state to intro_run"])
    elif view.step == 3:
        intro_run_start(state)
        view.step = 4
    elif view.step == 4:
        done = intro_run_left(state, view)
        if done:
            view.step = 5
    elif view.step == 5:
        pause = intro_run_right(state, view)
        if pause == true:
            view.step = 6
    elif view.step == 6:
        done = intro_pause(state, view)
        if done:
            view.step = 5

() intro_run_start(object state):
    game = state.game
    pacman = game.pacman
    game.ball = thing_new(new_id(state), "Ball", [0,0,0], [], [], state.geometries.ball, null)
    extend(state.world.children, [pacman, game.ball])
    extend(state.world.children, game.number_bubbles)
    z = 117
    v_x = -100
    thing_set_position(game.ball, [33.0, 0.0, 120])
    thing_set_position(pacman, [224.0, 0.0, z])
    #thing_set_world_bounds(pacman, matrix_identity())
    print(["pacman world bounds", pacman.world_bounds])
    pacman.velocity = [v_x, 0, 0]
    pacman.animate_start = state.now
    place_pacman(pacman, 0, 0)
    x = 250
    for enemy in game.enemies:
        thing_set_position(enemy, [x, 0.0, z])
        enemy.velocity = [v_x, 0, 0]
        #thing_set_world_bounds(enemy, matrix_identity())
        print(["enemy world bounds", enemy.world_bounds])
        x+=16
    extend(state.world.children, game.enemies)


# framework for pausing until child is done.
# normal: setup, run, setup, run, setup, run
# subroutine: setup, run, pause, setup, run, resume
# basically, there are children that you block wait on,
# and children that run in parallel (though you do have to wait 
# for them to finish when you are done)

(bool done) intro_run_left(object state, object view):
    game = state.game
    pacman = game.pacman

    if pacman.world_bounds.position[0] < 38:
        thing_set_position_y(game.ball, -1000)
        v_x = 100
        pacman.velocity = [v_x, 0, 0]
        place_pacman(pacman, 0, 1)
        for enemy in game.enemies:
            enemy.children = enemy.ghost_children
            enemy.velocity = [v_x, 0, 0]
        done = true
        return

    delta = state.delta
    #print(["pacman world bounds", pacman.world_bounds])
    bump_thing(pacman, [], delta)
    distance_delta = pacman.position_delta
    #print(["distance delta", distance_delta])
    animate(state.animations.pacman, state.things, state.geometries, state.now - pacman.animate_start)
    #animate(state.animations.ball, state.things, state.geometries, state.now - pacman.animate_start)
    for enemy in game.enemies:
        move_velocity(state, enemy, enemy.velocity)
        thing_set_position(enemy, sum_arrays(enemy.position, distance_delta))
        #print(["enemy world bounds", enemy.world_bounds])


(bool pause) intro_run_right(object state, object view):
    game = state.game
    pacman = game.pacman
    if pacman.world_bounds.position[0] > 240:
        # done.
        view_exit(view, {})
        return

    delta = state.delta
    animate(state.animations.pacman, state.things, state.geometries, state.now - pacman.animate_start)
    bump_thing(pacman, game.enemies, delta)
    distance_delta = pacman.position_delta
    for enemy in game.enemies:
        move_velocity(state, enemy, enemy.velocity)
        thing_set_position(enemy, sum_arrays(enemy.position, [distance_delta[0]/2, 0, 0]))
        #print(["enemy world bounds", enemy.world_bounds])
    for touch in pacman.collisions:
        print(["run_idle hit something", touch.thing.type, touch.thing.position])
        if touch.thing.type == "Enemy":
            # both pacman and enemy disappears.
            # number appears.
            # frozen for a second.
            game.guys_paused_start = state.now
            thing_set_position_y(pacman, -1000)
            thing_set_position_y(touch.thing, -1000)
            thing_set_position(game.number_bubbles[view.number_eaten], [pacman.position[0], 0, pacman.position[2]])
            view.number_eaten += 1
            pause = true
            return

(bool done) intro_pause(object state, object view):
    #if game.guys_paused:
        # hang tight
        #print(["paused", state.now - game.guys_paused_start])
    game = state.game
    if (state.now - game.guys_paused_start) > 1.0:
        pacman = game.pacman
        thing_set_position_y(pacman, 0.0)
        v_x = 100
        pacman.velocity = [v_x, 0, 0]
        game.number_bubbles[view.number_eaten - 1].position[1] = -1000.0
        done = true
